### Проблема:

- сейчас каждый клиент подключаясь к api напрямую нагружает его polling запросами
- при этом данные для каждого клиента могут отличаться друг от друга, потому что polling не дает синхранизации
- избыточный трафик - клиент получает сырые данные и каждое обновление их фильтрует
- долгая первичная загрузка ( FCP ) - проблема вытекающая из предыдущего пункта, чем меньше вес пакета, тем быстрее пользователь сможет увидеть контент и заимодействовать с приложением

### Варианты решения

Ввести промежуточный слой - bff/api gateway, между `Backend API`(и различными сервисами) и фронтендом.

Благодаря этому можно перенести бизнес логику на `bff` , сделав фронтенд простым, а также оптимизировать запросы, улучшив пользовательский опыт.

Первые шаги:
Вынести логику связанную с обработкой пулов и рейтов на сервер.
Обновлять и рассчитывать их на сервере, а клиенту отдавать подготовленные данные через websocket или sse соеденение

Списки самих пулов или активов присылать только при инициализации по http, а изменяемые данные (рейты, какие либо поля в пулах), высчитывать на сервере и стримить, и уже на клиенте связывать.

Что сделал

создал MVP `bff` сервера, архитектура - своеобразный DDD. Есть два модуля (assets/pools) они содержат контроллеры, роутер, репозитории и т.п., сервисы вынесены отдельно, есть оч простой ioc для di (можно обойтись без этого).

При инициализации `bff` подключается к `Backend API` для получения данных с помощью сервисов, данные сохраняются в репозиторий модуля. Чтобы отправлять данные на клиент как только они обновились, используется `EventEmitter` (решение считаю узким местом, но это чтобы протестить концепцию)

[GitHub - RuslanShkhaliev/bffddtest](https://github.com/RuslanShkhaliev/bffddtest/tree/main)

### Взаимодействие `bff` - `Backend API`

bff устанавливает соеденение с `Backend API` для получения данных о пулах, по прежднему с помощью polling’a, данные сохраняются в репозиториях модулей с которыми они связаны (планируется, что репозитории отвечают за хранение и обработку данных перед отправкой на клиент)

### Взаимодействие `клиент` - `bff`

Протестировано три подхода, все имеют так или иначе плюсы, как минимум разгружая `API` и уменьшая трафик

`Polling`:
Здесь два варианта

Клиент интервально опрашивает сервер (polling) - получает данные и здесь 2 варианта:
1. получает данные которые хранит репозиторий (он обновляется по своему таймеру, не зависимо от запроса клиента), своего рода кеш, но каждый пользователь получает одни и те же данные. При текущем раскладе клиенты получает условно актуальные данные и это только при первом запросе, дальше данные обновляются только через определенный интервал, так что большой разницы нет в плане актуальности, а вот нагрузка в этом случае меньше.

```tsx
public getPools = async (
		_req: IncomingMessage,
		res: ServerResponse,
	): Promise<void> => {
		try {
			res.writeHead(200, { 'Content-Type': 'application/json' });

			const data = this.poolsRepository.getPools(); // чтение из репозитория
			res.end(JSON.stringify(data));
		} catch (err: unknown) {
			console.log(err);
			res.writeHead(500);
			res.end(new Error('Ошибка получения пулов'));
		}
	};
```

[GitHub - RuslanShkhaliev/bffddtest](https://github.com/RuslanShkhaliev/bffddtest/tree/main)

1. дергает `api` , т.е. работает также как и сейчас клиент- `API` , из преимуществ только уменьшение трафика за счет обработки данных на сервере.
   Этот подход дает меньше всего профита, потому что инициатор запроса клиент и будут гоняться данные, которые могли еще не обновиться, кроме того каждый клиент делает это по своему интервалу и между разыми устройствами данные могут отличаться.

```tsx
public getPools = async (
		_req: IncomingMessage,
		res: ServerResponse,
	): Promise<void> => {
		try {
			const data = await this.poolsService.getPools(); // ходит к бекенду каждый запрос от клиента
			res.end(JSON.stringify(data));
		} catch (err: unknown) {
			console.log(err);
			res.writeHead(500);
			res.end(new Error('Ошибка получения данных пулов'));
		}
	};
```

[GitHub - RuslanShkhaliev/bffddtest at pools-sync](https://github.com/RuslanShkhaliev/bffddtest/tree/pools-sync)

Типа замеры
но у меня сервер самый дешманский и я не умею настраивать, по мне так может быть лучше (pools-lite это наш текущий запрос)

![Untitled](https://prod-files-secure.s3.us-west-2.amazonaws.com/eda5c1aa-6643-40cf-aa16-fafacbbb4674/977795a6-d7c3-48bf-915a-dfa64cd07b86/Untitled.png)

`SSE`:

С этим подходом мы инверсируем взаимодействие, теперь клиент получает данные тогда, когда они фактически обновились, при чем каждый клиент видит одни и те же данные. Однако, появляется проблема связанная с тем как работает EventSourcing, а именно накопление сообщений в течении стрима (это увеличивает потребление памяти вкладки), никакой возможности с помощью api браузера фиксануть это я не нашел, но можно интервально закрывать и открывать соеденение, дабы очищать память.
Ну из плюсов, sse при обрыве коннекта, будет пытаться реконнектиться автоматически, в отличии от wss.

[GitHub - RuslanShkhaliev/bffddtest at pools-stream](https://github.com/RuslanShkhaliev/bffddtest/tree/pools-stream)

`Websocket` :https://github.com/RuslanShkhaliev/bffddtest/tree/pools-stream
При инициализации `bff` открываем соеденение, при обновлении данных от `API` шлем сообщение через `WS` , на клиенте при инициализации подключаемся к нужному wss порту и получаем данные.
Самый оптимальный вариант, так как нет болячек `SSE` .

Форс апдейты (запрашиваемые вручную юзерами) по прежднему будут работать, но это стоит кешировать, я этого не касался.

Если говорить комплексно о bff, то плюсов могу перечислить еще больше. Это и вариант взаимодействия между `API` и `bff` и `bff` с `клиентом` , захотели сделали `GQL` , замапили данные как нам удобно, упростили фронт и т.п.

[GitHub - RuslanShkhaliev/bffddtest at pools-wss](https://github.com/RuslanShkhaliev/bffddtest/tree/pools-wss)
